mod shaders;

use rust_lib::{
    draw::{
        colors,
        shaders::{DefaultObjectBuilder, DefaultShader},
        RectBuilder,
    },
    game::{self, entry_point, AppResource, DrawResource, TextureHandle, UpdateTime},
    geometry::{ortho, Mat4, Point, Rect, Size, Vec2},
    renderer::{color::*, graph::*},
    text,
    window::{TouchPhase, TouchScreen},
};

include!(concat!(env!("OUT_DIR"), "/managers.rs"));

const CLEAR_COLOR: SrgbRgba = SrgbRgba([0.95, 0.93, 0.91, 1.0]);

#[derive(Debug)]
pub struct Game {
    canvas: TextureHandle,
    spot_count: usize,
    spots_touched: Vec<Point>,
}

impl game::Game for Game {
    const GAME_NAME: &'static str = "{{stylized_app_name}}";

    type UserEvent = ();
    type AssetManager = AssetManager;

    fn cargo_manifest_dir() -> &'static str {
        env!("CARGO_MANIFEST_DIR")
    }

    fn new(init_resource: &mut AppResource<'_, Self>, _assets: &AssetManager) -> Self {
        Self {
            canvas: init_resource.create_blank_texture(
                colors::INVISIBLE,
                init_resource.swapchain_size(),
            ).expect("failed to create canvas texture"),
            spot_count: 0,
            spots_touched: Default::default(),
        }
    }

    fn update(
        &mut self,
        _update_time: UpdateTime,
        _update_resource: &mut AppResource<'_, Self>,
        _assets: &AssetManager,
    ) {}

    fn draw(
        &mut self,
        draw_resource: &mut DrawResource<'_>,
        assets: &AssetManager,
    ) -> GraphBuilder {
        let screen_rect = draw_resource.window.screen_surface_rect().unwrap();
        let screen_size = screen_rect.size();
        let proj = draw_resource.window.ortho();
        StageBuilder::new()
            .with_attachment(StageAttachment::swapchain(Some(CLEAR_COLOR.to_linear())))
            .with_draw::<DefaultShader>(DrawBuilder::new(proj, ())
                .with_object(self.draw_background(assets, screen_rect))
                .with_object(self.draw_canvas(screen_rect))
                .with_object(self.draw_score(draw_resource, assets))
            )
            .with_sub_stage(self.draw_spots_on_canvas(assets, screen_size, proj))
            .into_graph_builder()
    }

    fn handle_touch(
        &mut self,
        touch: TouchScreen,
        _time: std::time::Instant,
        touch_resource: &mut AppResource<'_, Self>,
        _assets: &AssetManager,
    ) {
        if touch.phase == TouchPhase::Began
        || touch.phase == TouchPhase::Moved {
            let size = touch_resource.window.screen_surface_size().unwrap();
            let rect = Rect::with_top_left(Point::zero(), size);
            if rect.contains(&touch.position) {
                touch_resource.verts_changed();
                self.spot_count = self.spot_count.saturating_add(1);
                self.spots_touched.push(touch.position);
            }
        }
    }
}

impl Game {
    fn draw_background(
        &mut self,
        assets: &AssetManager,
        screen_rect: Rect,
    ) -> DefaultObjectBuilder {
        let logo = assets.textures.logo();
        let bg_size = logo
            .size()
            .map(|n| n as f32)
            .scaled_to_fill_and_fit(screen_rect.size());
        RectBuilder::new(Rect::with_center(screen_rect.center(), bg_size))
            .with_texture(logo.id())
            .into_object_builder()
    }

    fn draw_canvas(
        &mut self,
        screen_rect: Rect,
    ) -> DefaultObjectBuilder {
        RectBuilder::new(screen_rect)
            .with_texture(self.canvas.id())
            .into_object_builder()
    }

    fn hype_color(&self) -> SrgbRgba {
        SrgbRgba(if self.spot_count > 1000 {
            [1.0, 0.0, 1.0, 1.0]
        } else if self.spot_count > 700 {
            [0.0, 0.0, 1.0, 1.0]
        } else if self.spot_count > 500 {
            [0.0, 1.0, 0.0, 1.0]
        } else if self.spot_count > 300 {
            [1.0, 1.0, 0.0, 1.0]
        } else if self.spot_count > 100 {
            [1.0, 0.0, 0.0, 1.0]
        } else {
            [0.0, 0.0, 0.0, 1.0]
        })
    }

    fn draw_score(
        &self,
        draw_resource: &mut DrawResource<'_>,
        assets: &AssetManager,
    ) -> DefaultObjectBuilder {
        let spot_count = self.spot_count.to_string();
        let para = text::expand_and_parse(
            "[0: %0] spot%1",
            &text::subs! {
                0 => &spot_count,
                1 => if self.spot_count != 1 { "s" } else { "" },
            },
            text::Style::new(assets.fonts.fira_sans_regular(), 64., colors::BLACK),
            &text::tags! {
                0 => text::Style::new(
                    assets.fonts.fira_sans_regular(),
                    64.,
                    self.hype_color(),
                ),
            },
        ).unwrap();
        let point = draw_resource.window.screen_safe_surface_origin().unwrap() + Vec2::new(32., 32.);
        draw_resource.draw_text(std::iter::once(
            para.position(point).to_inner()
        ))
    }

    fn draw_spots(
        &mut self,
        assets: &AssetManager,
        screen_size: Size,
    ) -> impl Iterator<Item = DefaultObjectBuilder> + '_ {
        let spot_size = {
            let spot_radius = screen_size.width.min(screen_size.height) / 5.;
            Size::new(spot_radius, spot_radius)
        };
        let spot_texture = assets.textures.spot();
        self.spots_touched
            .drain(..)
            .map(move |spot| RectBuilder::new(Rect::with_center(spot, spot_size))
                .with_texture(spot_texture.id())
                .into_object_builder()
            )
    }

    fn draw_spots_on_canvas(
        &mut self,
        assets: &AssetManager,
        screen_size: Size,
        proj: Mat4,
    ) -> AttachmentStageBuilder {
        StageBuilder::new()
            .with_attachment(StageAttachment::texture(self.canvas.id(), None))
            .with_draw::<shaders::SwizzleShader>(DrawBuilder::from_objects(
                proj,
                (),
                self.draw_spots(assets, screen_size).collect(),
            ))
    }
}

#[entry_point]
fn start_game() {
    game::run::<Game>();
}
