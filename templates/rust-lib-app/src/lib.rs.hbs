mod shaders;

use rust_lib::{
    app::{self, app_env, entry_point, App, AppResource, DrawResource, TextureHandle},
    draw::RectBuilder,
    gal::{FontId, RenderNode, Scale, Text, Texture},
    geometry::{
        self,
        chromatose::{colors, LinRgba},
        pee::StarBuilder,
        Mat4, Point, Rect, ScreenRect, ScreenSize, ScreenVec2, Size,
    },
    renderer::builders::*,
    window::{Touch, TouchPhase},
};

include!(concat!(env!("OUT_DIR"), "/managers.rs"));

#[derive(Debug)]
pub struct Game {
    assets: AssetManager,
    canvas: TextureHandle,
    spot_count: usize,
    spots_touched: Vec<Point>,
}

impl App for Game {
    const NAME: &'static str = "{{app.stylized-name}}";

    type UserEvent = ();

    fn new(init_resource: &mut AppResource<'_>) -> Self {
        let size = init_resource.window.screen_surface_size();
        Self {
            assets: AssetManager::new(init_resource),
            canvas: init_resource
                .create_blank_texture(colors::INVISIBLE_SRGB, size)
                .expect("failed to create canvas texture"),
            spot_count: 0,
            spots_touched: Default::default(),
        }
    }

    fn default_font(&self) -> FontId {
        self.assets.fonts.ma_shan_zheng_regular()
    }

    fn default_text_scale(&self) -> Scale {
        Scale::uniform(64.0)
    }

    fn handle_touch(
        &mut self,
        touch: Touch,
        _time: rust_lib::app::TimePoint,
        touch_resource: &mut AppResource<'_>,
    ) {
        if touch.phase == TouchPhase::Began || touch.phase == TouchPhase::Moved {
            let size = touch_resource.window.screen_surface_size();
            let rect = Rect::with_top_left(Point::zero(), size.to_f32());
            if rect.contains(&touch.position) {
                touch_resource.request_redraw();
                self.spot_count = self.spot_count.saturating_add(1);
                self.spots_touched.push(touch.position);
            }
        }
    }

    fn draw(&mut self, draw_resource: &mut DrawResource<'_>) -> RenderNode {
        let screen_rect = draw_resource.window.screen_surface_rect();
        RenderNode::new()
            .with_child(self.draw_background(screen_rect))
            .with_child(self.draw_transparent_rects(screen_rect))
            .with_child(self.draw_spots_on_canvas(screen_rect))
            .with_child(self.draw_score(draw_resource))
            .with_child(
                RenderNode::poly_builder(
                    StarBuilder::new(5)
                        .with_center(screen_rect.bottom_right().map(|x| x as f32 - 50.0)),
                )
                .with_color(colors::MAGIC_PINK),
            )
    }
}

impl Game {
    fn draw_background(&mut self, screen_rect: ScreenRect) -> impl Into<RenderNode> {
        let logo = self.assets.textures.logo();
        let bg_size = logo
            .size_f32()
            .scaled_to_fill_and_fit(screen_rect.size().to_f32());
        RenderNode::rect_builder(screen_rect.to_f32())
            .with_color(colors::UNICORN_HAIR)
            .with_child(
                RenderNode::rect_builder(Rect::with_center(screen_rect.center().to_f32(), bg_size))
                    .with_texture(**logo),
            )
    }

    fn draw_transparent_rects(&mut self, screen_rect: ScreenRect) -> impl Into<RenderNode> {
        let scalar_size = screen_rect.width().min(screen_rect.height()) / 7;
        let rect_size = ScreenSize::square(scalar_size);
        let tl_rect = ScreenRect::with_top_left(Default::default(), rect_size);
        let br_rect = ScreenRect::with_top_left(tl_rect.center(), rect_size);
        let target_size =
            ScreenRect::from_points(tl_rect.top_left(), br_rect.bottom_right()).size();
        let two_rects = RenderNode::rect_builder(tl_rect.to_f32())
            .with_color(colors::RED)
            .with_child(RenderNode::rect_builder(br_rect.to_f32()).with_color(colors::BLUE));
        RenderNode::rect_builder(
            ScreenRect::with_center(screen_rect.center(), target_size).to_f32(),
        )
        .with_texture(Texture::render_texture(two_rects).with_size(target_size))
        .with_color(LinRgba::new(0.5, 0.5, 0.5, 0.5))
    }

    fn draw_score(&self, draw_resource: &mut DrawResource<'_>) -> impl Into<RenderNode> {
        let offset = ScreenVec2::new(0, 32);
        let pos = draw_resource.window.screen_safe_surface_rect().top_center() + offset;
        RenderNode::text_builder(pos.to_f32())
            .with_text(Text::new(self.spot_count.to_string()).with_color(colors::FUCHSIA_SRGB))
            .with_text(if self.spot_count != 1 {
                " spots (汉语)"
            } else {
                " spot (汉语)"
            })
            .with_bounds(draw_resource.window.screen_safe_surface_size().to_f32())
            .with_align_top_center()
    }

    fn draw_spots(&mut self, screen_size: ScreenSize) -> RenderNode {
        let proj = geometry::ortho(screen_size);
        let spot_size = {
            let spot_radius = screen_size.width.min(screen_size.height) as f32 / 6.;
            Size::new(spot_radius, spot_radius)
        };
        let spot_texture = self.assets.textures.spot();
        let mut pipeline_scene =
            PipelineScene::<shaders::SwizzleShader>::new((proj.into(), ()).into());
        self.spots_touched.drain(..).for_each(|spot| {
            RectBuilder::<Mat4, ()>::new(Rect::with_center(spot, spot_size))
                .with_texture(**spot_texture)
                .add_to_scene(&mut pipeline_scene);
        });
        RenderNode::from_scene(pipeline_scene)
    }

    fn draw_spots_on_canvas(&mut self, screen_rect: ScreenRect) -> impl Into<RenderNode> {
        let spots = RenderNode::new().with_child(self.draw_spots(screen_rect.size()));
        RenderNode::rect_builder(Rect::with_center(
            screen_rect.center().to_f32(),
            screen_rect.size().to_f32(),
        ))
        .with_texture(
            Texture::render_texture(spots)
                .with_target(*self.canvas)
                .with_clear(None),
        )
    }
}

#[entry_point(Game)]
fn start_app() {
    app::run::<Game>(app_env!());
}
