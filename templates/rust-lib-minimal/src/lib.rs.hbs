// mod shaders;

use rust_lib::{
    app::{self, app_env, entry_point, App, AppResource, DrawResource, TimePoint},
    gal::RenderNode,
    geometry::{chromatose::colors, Point, Rect, ScreenRect},
    window::{Touch, TouchPhase},
};

include!(concat!(env!("OUT_DIR"), "/managers.rs"));

#[derive(Debug)]
pub struct Game {
    assets: AssetManager,
}

impl App for Game {
    const NAME: &'static str = "{{app.stylized-name}}";

    type UserEvent = ();

    fn new(init_resource: &mut AppResource<'_>) -> Self {
        Self {
            assets: AssetManager::new(init_resource),
        }
    }

    fn handle_touch(
        &mut self,
        touch: Touch,
        _time: TimePoint,
        touch_resource: &mut AppResource<'_>,
    ) {
        if touch.phase == TouchPhase::Began || touch.phase == TouchPhase::Moved {
            let size = touch_resource.window.screen_surface_size();
            let rect = Rect::with_top_left(Point::zero(), size.to_f32());
            if rect.contains(&touch.position) {
                println!("touched {:#?}", touch);
            }
        }
    }

    fn draw(&mut self, draw_resource: &mut DrawResource<'_>) -> RenderNode {
        let screen_rect = draw_resource.window.screen_surface_rect();
        RenderNode::new()
            .with_child(self.draw_background(screen_rect))
    }
}

impl Game {
    fn draw_background(&mut self, screen_rect: ScreenRect) -> impl Into<RenderNode> {
        let screen_rect = screen_rect.to_f32();
        let logo = self.assets.textures.logo();
        let bg_size = logo.size_f32().scaled_to_fill_and_fit(screen_rect.size());
        RenderNode::rect_builder(screen_rect)
            .with_color(colors::UNICORN_HAIR)
            .with_child(
                RenderNode::rect_builder(Rect::with_center(screen_rect.center(), bg_size))
                    .with_texture(**logo),
            )
    }
}

#[entry_point(Game)]
fn start_app() {
    app::run::<Game>(app_env!());
}
